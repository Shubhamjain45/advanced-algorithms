'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var merge = require('lodash.merge');
var isEqual = require('lodash.isequal');

var helpers = require('./helpers');

var defaultOptions = {
  required: false,
  strings: {
    detectFormat: true,
    customFnc: null
  },
  arrays: {
    mode: 'all'
  },
  objects: {
    customFnc: null
  }
};

var skipReverseFind = ['hostname', 'host-name', 'alpha', 'alphanumeric', 'regex', 'regexp', 'pattern'];
var filteredFormats = helpers.stringFormats.filter(function (item) {
  return skipReverseFind.indexOf(item) < 0;
});

function getCommonTypeFromArrayOfTypes(arrOfTypes) {
  var lastVal = void 0;
  for (var i = 0, length = arrOfTypes.length; i < length; i++) {
    var currentType = arrOfTypes[i];
    if (i > 0) {
      if (currentType === 'integer' && lastVal === 'number') {
        currentType = 'number';
      } else if (currentType === 'number' && lastVal === 'integer') {
        lastVal = 'number';
      }
      if (lastVal !== currentType) return null;
    }
    lastVal = currentType;
  }
  return lastVal;
}

var ToJsonSchema = function () {
  function ToJsonSchema(options) {
    _classCallCheck(this, ToJsonSchema);

    this.options = merge({}, defaultOptions, options);
  }

  _createClass(ToJsonSchema, [{
    key: 'getCommonArrayItemsType',
    value: function getCommonArrayItemsType(arr) {
      return getCommonTypeFromArrayOfTypes(arr.map(function (item) {
        return helpers.getType(item);
      }));
    }

    /**
     * Tries to find the least common schema that would validate all items in the array. More details
     * helpers.mergeSchemaObjs description
     * @param {array} arr
     * @returns {object|null}
     */

  }, {
    key: 'getCommonArrayItemSchema',
    value: function getCommonArrayItemSchema(arr) {
      var _this = this;

      var schemas = arr.map(function (item) {
        return _this.getSchema(item);
      });
      // schemas.forEach(schema => console.log(JSON.stringify(schema, '\t')))
      return schemas.reduce(function (acc, current) {
        return helpers.mergeSchemaObjs(acc, current);
      }, schemas.pop());
    }
  }, {
    key: 'getObjectSchemaDefault',
    value: function getObjectSchemaDefault(obj) {
      var _this2 = this;

      var requiredFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      var schema = { type: 'object' };
      var objKeys = Object.keys(obj);
      if (objKeys.length > 0) {
        schema.properties = objKeys.reduce(function (acc, propertyName) {
          var required = void 0; // keep it undefined if not in requiredFields
          if (requiredFields.indexOf(propertyName) >= 0) {
            required = true;
          }
          acc[propertyName] = _this2.getSchema(obj[propertyName], required); // eslint-disable-line no-param-reassign
          return acc;
        }, {});
      }
      return schema;
    }
  }, {
    key: 'getObjectSchema',
    value: function getObjectSchema(obj) {
      if (this.options.objects.customFnc) {
        return this.options.objects.customFnc(obj, this.getObjectSchemaDefault.bind(this));
      }
      return this.getObjectSchemaDefault(obj);
    }
  }, {
    key: 'getArraySchemaMerging',
    value: function getArraySchemaMerging(arr) {
      var schema = { type: 'array' };
      var commonType = this.getCommonArrayItemsType(arr);
      if (commonType) {
        schema.items = { type: commonType };
        if (commonType !== 'integer' && commonType !== 'number') {
          var itemSchema = this.getCommonArrayItemSchema(arr);
          if (itemSchema) {
            schema.items = itemSchema;
          }
        } else {
          if (this.options.required) {
            schema.items.required = true;
          }
        }
      }
      return schema;
    }
  }, {
    key: 'getArraySchemaNoMerging',
    value: function getArraySchemaNoMerging(arr) {
      var schema = { type: 'array' };
      if (arr.length > 0) {
        schema.items = this.getSchema(arr[0]);
      }
      return schema;
    }
  }, {
    key: 'getArraySchemaUniform',
    value: function getArraySchemaUniform(arr) {
      var schema = this.getArraySchemaNoMerging(arr);

      if (arr.length > 1) {
        for (var i = 1; i < arr.length; i++) {
          if (!isEqual(schema.items, this.getSchema(arr[i]))) {
            throw new Error('Invalid schema, incompatible array items');
          }
        }
      }
      return schema;
    }
  }, {
    key: 'getArraySchema',
    value: function getArraySchema(arr) {
      if (arr.length === 0) {
        return { type: 'array' };
      }
      switch (this.options.arrays.mode) {
        case 'all':
          return this.getArraySchemaMerging(arr);
        case 'first':
          return this.getArraySchemaNoMerging(arr);
        case 'uniform':
          return this.getArraySchemaUniform(arr);
        default:
          throw new Error('Unknown array mode option \'' + this.options.arrays.mode + '\'');
      }
    }
  }, {
    key: 'getStringSchemaDefault',
    value: function getStringSchemaDefault(value) {
      var schema = { type: 'string' };

      if (!this.options.strings.detectFormat) {
        return schema;
      }

      var index = filteredFormats.findIndex(function (item) {
        return helpers.isFormat(value, item);
      });
      if (index >= 0) {
        schema.format = filteredFormats[index];
      }

      return schema;
    }
  }, {
    key: 'getStringSchema',
    value: function getStringSchema(value) {
      if (this.options.strings.customFnc) {
        return this.options.strings.customFnc(value, this.getStringSchemaDefault.bind(this));
      }
      return this.getStringSchemaDefault(value);
    }

    /**
     * Gets JSON schema for provided value
     * @param value
     * @param {boolean|null} required - If true/false, then it will be assumed that value is required/optional. If
     * null, than the required field is omitted completely in the returned schema (this doesn't have an effect on subitems).
     * @param {boolean} arrayMerge - If true, array items will be merged to least compatible scheme if types are
     * incompatible.
     * @returns {object}
     */

  }, {
    key: 'getSchema',
    value: function getSchema(value, required) {
      var type = helpers.getType(value);
      if (!type) {
        throw new Error("Type of value couldn't be determined");
      }

      var schema = void 0;
      switch (type) {
        case 'object':
          schema = this.getObjectSchema(value);
          break;
        case 'array':
          schema = this.getArraySchema(value);
          break;
        case 'string':
          schema = this.getStringSchema(value);
          break;
        default:
          schema = { type: type };
      }

      if (typeof required === 'boolean') {
        schema.required = required;
      } else if (this.options.required) {
        schema.required = true;
      }

      return schema;
    }
  }]);

  return ToJsonSchema;
}();

function toJsonSchema(value, options) {
  var tjs = new ToJsonSchema(options);
  return tjs.getSchema(value);
}

module.exports = toJsonSchema;